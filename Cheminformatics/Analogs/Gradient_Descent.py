# Jonathan Borowsky and Nathan Levinzon, UCSF 2023

#This program uses a preexisting dockbase folder and INDOCK file, which could otherwise be generated by blastermaster
#it builds its own ligands from a list of smiles strings

import os
import time
import math
import sys

#from /nfs/home/jborowsky/rotation/css-1/
import extract_best_smiles
import analog_generator_061623

#---------------------------parameters--------------------------

#directory with all the scripts
pwd = os.getcwd()

lines_per_job = 50
#optional env arg: LINES_PER_JOB
#arg description: number of SMILES per job array element
#default: 50

#-------------------------utilities----------------------------

#unused
def lastline(filename):
	with open(filename, 'rb') as f:
		try:  # catch OSError and return the sole line in case of a one line file 
			f.seek(-2, os.SEEK_END)
			while f.read(1) != b'\n':
				f.seek(-2, os.SEEK_CUR)
		except OSError:
			f.seek(0)
		
		return f.readline().decode() #last line

def squeue_njobs(username, jobname):
	
	#pipe the squeue output into a temporary file
	temp_fn = "temp_squeue.txt"
	if os.path.exists(temp_fn):
		os.system(f"rm {temp_fn}")
	os.system(f"squeue -u {username} -n {jobname} > {temp_fn}")	
	
	#read the temporary file to determine queue contents
	fsq = open(temp_fn, "r")
	nlines = len([line for line in fsq])
	fsq.close()

	return nlines-1  #if the queue is empty only the header is present

#-------------------------other methods------------------------

def recursive_build_ligands(smiles_input_file, build_index):

	build_upper_root = f"{os.getcwd()}/build-ligands"
	build_upper = build_upper_root+"-"+str(build_index)
        #the hardcoded text in these does not appear to be user-definable
	build_logdir = "%s/%s.batch-3d.d/log/aaa.d" % (build_upper, smiles_input_file)
	build_indir = "%s/%s.batch-3d.d/in/aaa.d" % (build_upper, smiles_input_file)
	build_outdir = "%s/%s.batch-3d.d/out/aaa.d" % (build_upper, smiles_input_file)

	if squeue_njobs("jborowsky", "batch_3d") != 0:
		print("i\nWARNING:\
			\nnonempty queue: will not be able to accurately determine when all build jobs for this script are done.\
			\nThis job will not proceed past the current round of ligand building until your other 'build_3d' jobs are finished.\n")	

	#run script that submits ligand building jobs
	os.system("bash ../../build-ligands.sh %s %s %s" % (smiles_indir+"/"+smiles_input_file, build_upper, lines_per_job))

	print(f"Ligand building job array {build_index} submitted")
	
	init_wait = 5
	print(f"Waiting {init_wait} seconds")
	time.sleep(init_wait) #make sure the jobs have time to enter the queue before running the loop which inspects the queue contents

	#get the number of ligands from the input file
	with open(smiles_indir+"/"+smiles_input_file, "r") as f:
		n_ligands = sum(1 for _ in f)

	#number of jobs and hence number of output files to wait for before proceeding
	n_jobs = int(math.ceil(n_ligands/lines_per_job)) #50 is the default batch size

	#wait for the ligand building to finish
	#currently set to wait up to (1 million - increment) seconds
	maxstep = 10000000
	increment = 2 #seconds; actual cycle time is slightly longer
	n_queue_jobs = squeue_njobs("jborowsky", "batch_3d") #buffer since the number of jobs in the queue is calculated after printing in the interest of printing at the start of each loop iteration

	print(f"awaiting build job completion")

	for i in range(maxstep):
		print(f"{i*increment} seconds; {n_queue_jobs}/{n_jobs} jobs in queue", end="\r") #end="\r" makes the next print statement overwrite this

		#see how many jobs are still running
		n_queue_jobs = squeue_njobs("jborowsky", "batch_3d")

		if n_queue_jobs == 0: #if all the logs are done but output is not all generated, rerun the necessary build jobs
			print() #avoid overwriting time counter
				
			#see which sets of ligands built successfully
			outfiles = os.listdir(build_outdir)
			out_indices = [int(i.split(".")[0])-1 for i in outfiles]

			#get an ordered list of input files for each building run
			infiles = os.listdir(build_indir)
			infiles_screened = [i for i in infiles if len(i) == 3]
			infiles_screened.sort() #alphabetize

			#make a list of all the input files whose ligands were not built
			infiles_notbuilt = [infile for x, infile in enumerate(infiles_screened) if x not in out_indices]
			if len(infiles_notbuilt) == 0:
				break #once everything has been built, terminate and proceed to docking

			print(infiles_notbuilt)

			#concatenate all unbuilt input files into a single file
			os.chdir(build_indir)
		
			catstring = " ".join(infiles_notbuilt)
			smiles_out_file = f"{len(infiles_notbuilt)}-unbuilt-smiles-build{build_index+1}.smi"
			os.system(f"cat {catstring} > {smiles_indir}/{smiles_out_file}")	
		
			os.chdir(pwd)		
			
			#recursively run this method to build remaining ligands
			recursive_build_ligands(smiles_out_file, build_index+1)
			
			break

		elif i == maxstep-1:
			print("timed out waiting for ligands to build after " + str(maxstep*i) + " seconds.")

		#wait to avoid wasting excessive compute time on list iterations or overflowing the counter variable
		time.sleep(increment)

def rundock_wait(sdi_file, run_upper):
	
	os.system(f"bash {pwd}/run-dock.sh %s %s" % (sdi_file, run_upper))

	maxstep = 10000000
	increment = 2 #seconds; actual cycle time is slightly longer
	dockjobname="rundock"

	n_queue_jobs = squeue_njobs("jborowsky", dockjobname) #buffer since the number of jobs in the queue is calculated after printing in the interest of printing at the start of each loop iteration
	n_jobs = n_queue_jobs

	print(f"awaiting dock job completion")

	for i in range(maxstep):
		print(f"{i*increment} seconds; {n_queue_jobs}/{n_jobs} jobs in queue", end="\r") #end="\r" makes the next print statement overwrite this

		#see how many jobs are still running
		n_queue_jobs = squeue_njobs("jborowsky", dockjobname)

		if n_queue_jobs == 0: #if all the logs are done but output is not all generated, rerun the necessary build jobs
			print() #avoid overwriting time counter
			print("docking complete")
			break

		time.sleep(increment)

#-------------------------------run the above methods--------------------------------

rundir="run0"

def dockround(smiles_input_file, round_n, init_fakezinc_num):

	print()
	print( "+-----------------------------------------------------------+")
	print(f"|                       round {round_n}                            |")
	print( "+-----------------------------------------------------------+")

	os.chdir(pwd+"/"+rundir)

	round_dir = f"analoging-round-{round_n}"
	os.system(f"mkdir {round_dir}")
	os.chdir(round_dir)

	print()
	print("building analogues")
	print("-------------------------------------------------------------")

	analog_out_prefix = f"ampc-r{round_n}"
	analog_data = analog_generator_061623.main(smiles_indir, smiles_input_file, analog_out_prefix, init_fakezinc_num)
	analog_file = analog_data[0]
	#analog_fn = f"{path}/{analog_out_prefix}-analogues-i{len(smiles_zinc_input)}-o{len(lines_out)}.smi" 

	print()
	print("running fault-tolerant ligand building")
	print("-------------------------------------------------------------")

	recursive_build_ligands(analog_file, 0)

	print()
	print("building ligands finished; assembling dock input")
	print("-------------------------------------------------------------")

	sdi_file = "sdi.in"
	os.system("find * -type f -name '*.tar.gz' > %s" % sdi_file)

	print()
	print("running dock")
	print("-------------------------------------------------------------")

	run_upper="dock-output"
	rundock_wait(sdi_file, run_upper)

	os.chdir(run_upper)
	
	print()
	print("extracting best compound")
	print("-------------------------------------------------------------")

	rgx = f"./*/OUTDOCK.0"
	analogs_indir = f"{smiles_indir}/{analog_file}"
	outname = f"dock-scores-round{round_n}"

	best_smiles = extract_best_smiles.get_best_smiles(outname, analogs_indir, rgx)

	print("best compound:")
	print(best_smiles)

	single_smi_output_file = f"ampc-r{round_n}-smiles.smi"
	f3 = open(smiles_indir+"/"+single_smi_output_file, "w")
	f3.write(best_smiles[0]+" "+best_smiles[1])
	f3.close()
	
	dockround(single_smi_output_file, round_n+1, analog_data[1])


#starting smiles string
smiles_source_dir = f"{pwd}/input-files/input-smiles"
starting_smiles = f"worst-binder-1smiles.smi"

#get name of output directory
rundir=sys.argv[1]

#make output directories and copy starting smiles there
smile_io_dir = "smile-io"

os.system(f"mkdir {rundir}")
os.system(f"mkdir {rundir}/{smile_io_dir}")
os.system(f"cp {smiles_source_dir}/{starting_smiles} {rundir}/{smile_io_dir}")

smiles_indir = f"{pwd}/{rundir}/{smile_io_dir}"

#run docking gradient descent method
dockround(starting_smiles, 0, 0)


